---
layout: post
title: "理解JavaScript中的闭包"
date: 2019-06-10
author: "WangX"
catalog: true
header-style: text
tags:
    - JavaScript
---

#### 序言
闭包描述这样一种现象：闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。所声明的函数可以在声明之后的任何时间被调用，**甚至当该函数声明的作用域消失之后仍然可以调用**。
如下代码（例一）我们写过很多次：

```javascript
var outerValue = "out function";
function outerFunction() {
    console.log(outerValue);
}
outerFunction();
//输出 out function
```
上述代码在全局作用域中声明了变量outerValue和外部函数outerFunction，然后执行外部函数outerFunction。该函数可以“看见”并访问函数外部的变量，实际上这已经创建了一个**闭包**。**只不过该作用域从未消失**，该函数可以访问外部变量，因为它仍然在作用域内并且是可见的。再看下面一个例子（例二）：

```javascript
var outerValue = "out function";
var later;
function outerFunction() {
    var innerValue = "in function";
    function innerFunction() {
         console.log(outerValue);
          console.log(innerValue);
    }

    later = innerFunction;
   
}
outerFunction();
later();

//输出 out function
//输出 in function
```
上述代码中的第一处控制台输入，因为outerValue在全局作用域内，在任何地方都可以看见，所以第一处控制台输出 "out function"。外部函数outerFunction执行后，将内部函数innerFunction的引用赋值给全局变量later，再通过later调用内部函数。当later执行时，outerFunction的作用域已经不存在了，也已不可见了。但第二处控制台输出为 "in function"。也就是说 **当内部函数的作用域消失之后，再执行内部函数仍然可以内部变量innerValue**。这就是闭包神奇的地方。

闭包是函数和声明该函数的词法环境的组合。要理解闭包，就要搞清楚JavaScript的作用域是如何工作的，以及函数时执行发生了什么。

#### 词法环境

词法环境是JavaScript引擎内部用来跟踪标识符与特定变量之间的映射关系。词法环境是JavaScript作用域的内部实现机制，人们通常称为作用域。作用域（scope）是标识符（变量）在程序中的可见性范围。作用域规则是按照具体规则维护标识符的可见性，以确定当前执行的代码对这些标识符的访问权限。

当代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。**作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问**。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始只包含一个变量，即arguments对象（这个对象在全局环境中不存在）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象，则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

**标识符解析是沿着作用域链一级一级地搜索标识符的过程**。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

内部环境可以通过作用域访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。

#### 函数

在创建函数时，会创建一个与之相关联的词法环境，并存储在名为\[[Environmnet]]的内部属性上，也就是说无法直接访问或操作。这些环境是在函数创建时决定的。

在调用函数，都会创建一个新的执行环境，被推入执行上下文栈。此外还会创建一个与之相关联的词法环境。外部环境和新建的词法环境，**JavaScript引擎将调用函数的内置\[[Environmnet]]属性与创建函数的外部环境进行关联,从而构建起执行环境的作用域链。**

例二中，在创建函数outerFunction时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的\[[Environmnet]]属性中。当调用函数outerFunction时，会为函数创建一个新的执行环境，然后通过复制函数的\[[Environmnet]]属性中的对象**构建起执行环境的作用域链**。对于outerFunctiond函数的执行环境而言，其作用域链包含两个变量对象：outerFuncion活动对象和全局变量对象。对于innerFunction的执行环境而言，其作用域链包含三个变量对象：innerFunction活动对象、outerFunction活动对象和全局变量对象。在innerFunction函数执行时，访问outerValue,从innerFunction活动对象开始搜索作用域链，最终在全局变量对象中找到outerValue这个标识符。innerValue标识符则是在outerFunction活动对象中找到。 **作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象**。

**局部变量只在函数执行的过程中存在**。而在这个过程中，会为局部变量在栈或堆内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。垃圾收集器必须跟着哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。

例二中，outerFunction函数执行完后，JS的垃圾回收机制应该会自动将其标记为”离开环境”,等待回收机制下次执行，将其内存进行释放（标记清除）。但是later保存了函数innerFunction的引用，**正是这种引用赋值，阻止了垃圾回收机制将outerFunction进行回收，从而导致innerFunction的整条作用域链都被保存下来**。


#### 总结

**函数和其执行时的执行环境共同构成闭包，也就是当函数执行闭包才生成**。通过闭包可以访问创建闭包时所处环境中的全部变量。即使创建函数时所处的作用域已经消失但是函数仍然能够获得执行时所需的全部内容。闭包不是在创建的那一时刻的快照，而是一个真实的状态封装，只要闭包存在，就可以对变量进行修改。


#### 其他（标识符的注册）
在词法环境中注册标识符：
JavaScript代码的执行事实上是分两个阶段进行的。一旦创建了新的词法环境，就会执行第一阶段。在第一阶段，没有执行代码，但是JavaScript引擎会访问并注册
在当前词法环境所声明的变量和函数。JavaScript在第一阶段完成后开始执行第二阶段，具体如何执行取决于变量的类型（let、var、const和函数声明）以及环境类型
（全局环境，函数环境或块级作用域）。具体如下：
1. 如果是创建一个函数环境，那么创建形参及函数参数的默认值。如果是非函数环境，将跳过此步骤。
2. 如果创建的是全局或函数环境，就扫描当前代码进行函数声明（不会扫描其他函数的函数体），但是不会扫描函数表达式或箭头函数。对于所找到的函数声明，将创建
   函数，并绑定到当前环境与函数名相同的标识符上，若该标识符已经存在，那么该标识符的值将被重写。如果是块级作用域，将跳过此步骤。
3. 扫描当前代码进行变量声明。在函数或全局环境中，找到所有当前函数以及其他函数之外通过var声明的变量，并找到所有在其他函数或代码块之外通过let或const定义的
   变量。在块级环境中，仅查找当前块中通过let或const定义的变量。对于所查找到的变量，若该标识符不存在，进行注册并将其初始化为undefined。若该标识符以及存在，将保留其值。




