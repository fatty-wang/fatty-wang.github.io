---
layout: post
title: "ES6中的扩展"
date: 2019-02-14
author: "WangX"
catalog: true
header-style: text
tags:
    - JavaScript
    - ES6
---

## 字符串中的扩展
#### 字符串的Iterator接口
* ES6 为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历。除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。
#### 新增字符串方法
* ES6之前，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。
* ES6新增方法：
1. includes()：返回布尔值，表示是否找到了参数字符串。
2. startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
3. endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
4. repeat()：repeat方法返回一个新字符串，表示将原字符串重复n次。
5. matchAll()：返回一个正则表达式在当前字符串的所有匹配
6. String.raw()：往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串。
* ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。

#### 模板字符串
* 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。    

```javascript
// 普通字符串
`In JavaScript '\n' is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`
```
* 模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。

#### 标签模板
* 模板字符串可以紧跟在一个函数名后面，该函数将被条用来处理这个模板字符串。这称为“标签模板”功能(tagged template)。
* “标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。

## 数值的扩展
* ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。
* ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法，分别用来判断数值是否为有限的，是否为NaN。与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。
* ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
* Number.isInteger()用来判断一个数值是否为整数。
* ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。
* 根据规格，它表示 1 与大于 1 的最小浮点数之间的差。对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。
* Number.EPSILON实际上是 JavaScript 能够表示的最小精度。
* JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。
* Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。
#### Math对象的扩展
* ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。

#### 指数预算法
* ES2016 新增了一个指数运算符（**）。
* 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。   

```javascript
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
```

## 函数的扩展

#### 函数参数的默认值
* ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。    

```javascript
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello

function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
```
* 参数变量是默认声明的，在函数体中，不能使用let或const再次声明。
* 使用参数默认值时，函数不能有同名参数。
* 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是**惰性求值**的。
* 参数默认值可以与解构赋值的默认值，结合起来使用。
* 通常情况下，定义了默认值的参数，应该是函数的尾参数。
* 如果非尾部的参数设置默认值，这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。传入undefined，将触发该参数等于默认值，null则没有这个效果。    

```javascript
// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
```
* 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
* 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个**单独**的**作用域（context）**。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。

```javascript
var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2
```
上面代码中，参数y的默认值等于变量x。调用函数f时，**参数形成一个单独的作用域**。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。

#### rest参数
* ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个**数组**，该变量将多余的参数放入数组中。  

```javascript
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
```
* rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
* 函数的length属性，不包括 rest 参数。

#### 严格模式
* ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

#### name属性
* 函数的name属性，返回该函数的函数名。
* ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。

#### 箭头函数

* 使用方法略过
* 箭头函数使用注意点：
1. 函数体内的this对象，就是**定义时所在的对象**，而不是使用时所在的对象。**也就是说，箭头函数中的this是固定的**
2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
* this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

#### 尾递归
* ES6 第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。

## 数组的扩展
